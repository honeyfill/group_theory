\import Algebra.Group
\import Algebra.Monoid
\import Algebra.Pointed
\import Arith.Nat
\import Arith.Prime
\import Data.Bool
\import Data.Fin
\import Data.Or
\import Equiv (QEquiv)
\import Equiv.Univalence
\import Function
\import Function.Meta \hiding (#)
\import Logic
\import Logic.Meta
\import Meta
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Set
\import Set.Fin
\import Logic

\data Unit | unit


\class DecGroup \extends Group, DecSet {
}

\instance FinEq {n : Nat} : DecSet (Fin n)
  | decideEq => decideEq
  \where \func decideEq {n : Nat} (x y : Fin n) : Dec (x = y) \elim n, x, y
    | suc n1, 0, 0 => Dec.yes idp
    | suc n1, 0, suc y => Dec.no contradiction
    | suc n1, suc x, 0 => Dec.no contradiction
    | suc n1, suc x, suc y => \case decideEq x y \with {
      | yes e => Dec.yes (pmap fsuc e)
      | no n2 => Dec.no (\lam p => n2 (FinSet.suc-isInj x y p))
    }

\func fin0 : Fin 3 => 0
\func fin1 : Fin 3 => 1
\func fin2 : Fin 3 => 2

\func test1 : fin0 FinEq.== fin0 = true => idp
\func test2 : fin0 FinEq.== fin1 = false => idp

\class FinGroup \extends Group, FinSet {
  | groupOrder : Nat
  | groupOrder => finCard

  \func struct : DecGroup \cowith
    | E => E
    | ide => ide
    | * => *
    | ide-left => ide-left
    | ide-right => ide-right
    | *-assoc => *-assoc
    | inverse => inverse
    | inverse-left => inverse-left
    | inverse-right => inverse-right
    | decideEq x y => \case finEq \with {
      | inP a =>
        \let
          | q-equiv : QEquiv => =-to-Equiv {E} {Fin groupOrder} a
        \in
        \case FinEq.decideEq (q-equiv.f x) (q-equiv.f y) \with {
          | Dec.yes a1 => Dec.yes (q-equiv.isInj a1)
          | Dec.no _x => Dec.no (\lam t => _x (pmap q-equiv.f t))
        }
    }
}

\func nott (x : Bool) => not x

\func periodic_point {A : \Set} (f : A -> A) (n : Nat) (x : A) : \Prop => iterr f n x = x

\func order_e (G : Group) (e : G.E) (n : Nat) : \Prop =>
  \Sigma (periodic_point (G.* e) n e) (\Pi {m : Nat} (periodic_point (G.* e) m e) -> m >= n)

\func order_is_periodic {G : FinGroup} {e : G.E} : periodic_point (G.* e) (count_order G e) e =>
 unfold (periodic_point, count_order) (unfold {?})

\func order-is-order (G : FinGroup) (e : G.E) : order_e G e (count_order G e) =>
  (order_is_periodic, {?})

\func periodic_points {A : \Set} (f : A -> A) : \Set => \Sigma (x : A) (n : Nat) (periodic_point f n x)

-- \func nat_find {A : \Set} (ex : \Sigma )

\func minimal_period {A : \Set} (f : A -> A) (x : A) => {?}

\func test12 : periodic_point (\lam x => not x) 2 true => idp

\func count_order (G : FinGroup) (g : G.E) : Nat => helper G.groupOrder g g 1
  \where {
      \func helper (fuel : Nat) (g : G.E) (acc-g : G.E) (ans : Nat) : Nat \elim fuel
        | 0 => ans
        | suc t => \case decToBool (G.struct.decideEq G.ide acc-g) \with {
          | false => helper t g (acc-g G.* g) (suc ans)
          | true => ans
        }
    \func helper-gt-zero (fuel : Nat) (g acc-g : G.E) (ans : Nat) (p : ans > 0) : helper fuel g acc-g ans > 0
      \elim fuel
        | 0 => p
        | suc t => \case decToBool (G.struct.decideEq G.ide acc-g) \as b \return
            (\case b \with {
              | false => helper t g (acc-g G.* g) (suc ans)
              | true => ans
            }) > 0 \with {
          | false => helper-gt-zero t g (acc-g G.* g) (suc ans) NatSemiring.zero<suc
          | true => p
        }

    \func helper-is-order (fuel : Nat) (g acc-g : G.E) (ans : Nat) : G.pow g (helper fuel g acc-g ans) = G.ide => {?}
  }

\func count_order-gt-zero {G : FinGroup} {g : G.E} : count_order G g > 0 =>
  count_order.helper-gt-zero G G.groupOrder g g 1 NatSemiring.zero<suc

\func count_order-is-order (G : FinGroup) (g : G.E) : G.pow g (count_order G g) = G.ide =>
  unfold count_order (count_order.helper-is-order G G.groupOrder g g 1)

\func is-order (G : FinGroup) (g : G.E) (n : Nat) : \Prop =>
  \Sigma (G.pow g n = G.ide) (\Pi (m : Nat) (G.pow g m = G.ide) -> m >= n)

\class FinSubGroup \noclassifying (G : FinGroup) {
  | P : G -> \Prop
  | subgroupOrder : Nat
  | EqFin : (\Sigma (e : G.E) (P e)) = {\Set} Fin subgroupOrder
  | contains-ide : P ide
  | contains-comp {x y : G.E} (f : P x) (g : P y) : P (x * G.inverse y)

  \func struct : FinGroup \cowith
    | E => \Sigma (elem : G) (P elem)
    | ide => (G.ide, contains-ide)
    | * x y => (x.1 G.* y.1, contains-op x.2 y.2)
    | ide-left => ext G.ide-left
    | ide-right => ext G.ide-right
    | *-assoc => ext G.*-assoc
    | inverse x => (G.inverse x.1, contains-inv x.2)
    | inverse-left => ext G.inverse-left
    | inverse-right => ext G.inverse-right
    | finCard => subgroupOrder
    | finEq => inP EqFin

  \lemma contains-inv {x : G.E} (cont1 : P x) : P (G.inverse x) =>
    rewrite (inv G.ide-left) (contains-comp contains-ide cont1)

  \lemma contains-op {x y : G.E} (cont1 : P x) (cont2 : P y) : P (x * y) =>
    rewrite (inv (G.inverse-isInv y)) (contains-comp cont1 (contains-inv cont2))

}

\class CyclicFinGroup \extends FinGroup {
  | is-cyclic : TruncP (\Sigma (g : FinGroup.E) (\Pi (h : FinGroup.E) -> \Sigma (n : Nat) (Group.pow g n = h)))
}

\func \infix 9 ^ (k n : Nat) : Nat \elim n
  | 0 => 1
  | suc t => k Nat.* (k ^ t)

\class PGroup \extends FinGroup {
  | p : Nat
  | p-prime : isPrime p = true
  | is-p-group : \Pi (g : FinGroup.E) -> \Sigma (n : Nat) (Group.pow g (p ^ n) = Group.ide)
}

\class HomG {G H : FinGroup} (f : G -> H) {
  | is-hom {g h : G} : f (g G.* h) = (f g) H.* (f h)

  \lemma ide-is-ide : f G.ide = H.ide => {?}
}

--

{- Need to define:

  1. p-group.
    In Lean it is defined by elements (every elements order is divisible by p).
    In the book it is defined by the group order (the group order is divisible by p).

  2. p-Sylow group is defined as the maximum p-group.

  3. Cyclic group (?). Cyclic subgroup probably?
    Cyclic group is simply a group that generated by some element. Formally: "there is
    exists an element g : G, (forall x : G, x = g^n)

  3.1 Exponent. In Lean it is simply (min n : forall g : G -> g ^ n = 1)

  4. Hom is defined as usual.

  4. Factorization. Also we need left and right cosets. They are defined like in the book. TODO: пока что пропустить(!)
    TODO: Как в лине формулируется разбиение группы на косеты и разбиение множества на орбиты по действию?

  5. Center of the group. TODO: Определить в первую очередь

  6. Normal subgroup. Each subgroup of the center is normal. TODO: посмотреть в лине фактор-группы перед этим
    TODO: посмотреть TruncS (или как-то так)
    Page 6 here: https://tqft.net/web/notes/load.php?name=students/20180219-MitchRowett-ASC-report-on-Lean

  7. Canonical map G -> G / H.

  8. Image of the map and isomorphism.

  9. Also I need an index and Lagrange Theorem.

-}

\func count {n : Nat} (f : Fin n -> Bool) : Nat \elim n
  | 0 => 0
  | suc n => \case f (suc n) \with {
    | true => suc $ count (\lam x => f (suc x))
    | false => count (\lam x => f (suc x))
  }

\class SetWithGroupAction (G : FinGroup) (\classifying S : FinSet) {
  | action : G.E -> S -> S
  | action-ide {e : S} : action G.ide e = e
  | action-hom {x y : G.E} {e : S} : action (x * y) e = action x (action y e)
  }

{-
\instance OnItSelf {G : FinGroup} : SetWithGroupAction G G
  | action => G.*
  | action-ide => G.ide-left
  | action-hom => G.*-assoc
-}