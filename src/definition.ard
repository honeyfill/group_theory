\import Algebra.Group
\import Algebra.Monoid
\import Algebra.Pointed
\import Data.Bool
\import Function.Meta
\import Logic
\import Paths
\import Paths.Meta
\import Set.Fin
\import Arith.Prime

\class FinGroup \noclassifying \extends Group, FinSet {
  | groupOrder : Nat
  | groupOrder => finCard
}

\class FinSubGroup \noclassifying (G : FinGroup) {
  | P : G -> \Prop
  | subgroupOrder : Nat
  | EqFin : (\Sigma (e : G.E) (P e)) = {\Set} Fin subgroupOrder
  | contains-ide : P ide
  | contains-comp {x y : G.E} (f : P x) (g : P y) : P (x * G.inverse y)

  \func struct : FinGroup \cowith
    | E => \Sigma (elem : G) (P elem)
    | ide => (G.ide, contains-ide)
    | * x y => (x.1 G.* y.1, contains-op x.2 y.2)
    | ide-left => ext G.ide-left
    | ide-right => ext G.ide-right
    | *-assoc => ext G.*-assoc
    | inverse x => (G.inverse x.1, contains-inv x.2)
    | inverse-left => ext G.inverse-left
    | inverse-right => ext G.inverse-right
    | finCard => subgroupOrder
    | finEq => inP EqFin

  \lemma contains-inv {x : G.E} (cont1 : P x) : P (G.inverse x) =>
    rewrite (inv G.ide-left) (contains-comp contains-ide cont1)

  \lemma contains-op {x y : G.E} (cont1 : P x) (cont2 : P y) : P (x * y) =>
    rewrite (inv (G.inverse-isInv y)) (contains-comp cont1 (contains-inv cont2))

}

\class CyclicFinGroup \extends FinGroup {
  | is-cyclic : \Sigma (g : FinGroup.E) (\Sigma (n : Nat) (\Pi (h : FinGroup.E) -> Group.pow g n = h))
}


\func \infix 9 ^ (k n : Nat) : Nat \elim n
  | 0 => 1
  | suc t => k Nat.* (k ^ t)

\class PGroup \extends FinGroup {
  | is_p_group {k n : Nat} {p : isPrime k = true} :
    \Pi (g : FinGroup.E) -> \Sigma (k : Nat) (Group.pow g (k ^ n) = Group.ide)
}

\class HomG {G H : FinGroup} (f : G -> H) {
  | is-hom {g h : G} : f (g G.* h) = (f g) H.* (f h)

  \lemma ide-is-ide : f G.ide = H.ide => {?}
}

--

{- Need to define:

  1. p-group.
    In Lean it is defined by elements (every elements order is divisible by p).
    In the book it is defined by the group order (the group order is divisible by p).

  2. p-Sylow group is defined as the maximum p-group.

  3. Cyclic group (?). Cyclic subgroup probably?
    Cyclic group is simply a group that generated by some element. Formally: "there is
    exists an element g : G, (forall x : G, x = g^n)

  3.1 Exponent. In Lean it is simply (min n : forall g : G -> g ^ n = 1)

  4. Hom is defined as usual.

  4. Factorization. Also we need left and right cosets. They are defined like in the book.

  5. Center of the group.

  6. Normal subgroup. Each subgroup of the center is normal.
    Page 6 here: https://tqft.net/web/notes/load.php?name=students/20180219-MitchRowett-ASC-report-on-Lean

  7. Canonical map G -> G / H.

  8. Image of the map and isomorphism.

  9. Also I need an index and Lagrange Theorem.

-}

\func count {n : Nat} (f : Fin n -> Bool) : Nat \elim n
  | 0 => 0
  | suc n => \case f (suc n) \with {
    | true => suc $ count (\lam x => f (suc x))
    | false => count (\lam x => f (suc x))
  }
